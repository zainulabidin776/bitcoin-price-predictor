name: Production CD Pipeline

on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - master

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    name: Build Docker Image and Deploy
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install mlflow python-dotenv
      
      - name: Get latest model from MLflow
        env:
          MLFLOW_TRACKING_URI: ${{ secrets.MLFLOW_TRACKING_URI }}
          MLFLOW_TRACKING_USERNAME: ${{ secrets.MLFLOW_TRACKING_USERNAME }}
          MLFLOW_TRACKING_PASSWORD: ${{ secrets.MLFLOW_TRACKING_PASSWORD }}
        continue-on-error: true
        run: |
          echo "Fetching latest production model from MLflow..."
          
          # Check if secrets are set
          if [ -z "$MLFLOW_TRACKING_URI" ]; then
            echo "::warning::MLFLOW_TRACKING_URI not set. Using default version."
            echo "latest" > model_version.txt
            exit 0
          fi
          
          python << PYTHON
          import mlflow
          import os
          
          try:
              # Connect to MLflow
              tracking_uri = os.getenv('MLFLOW_TRACKING_URI')
              if not tracking_uri:
                  print("No MLflow tracking URI provided")
                  with open("model_version.txt", "w") as f:
                      f.write("latest")
                  exit(0)
              
              mlflow.set_tracking_uri(tracking_uri)
              
              # Get latest production model
              model_name = "crypto-volatility-predictor"
              
              try:
                  client = mlflow.tracking.MlflowClient()
                  latest_versions = client.get_latest_versions(model_name, stages=["Production"])
                  
                  if latest_versions:
                      print(f"âœ“ Found production model version: {latest_versions[0].version}")
                      with open("model_version.txt", "w") as f:
                          f.write(latest_versions[0].version)
                  else:
                      print("No production model found, using latest")
                      with open("model_version.txt", "w") as f:
                          f.write("latest")
              except Exception as e:
                  print(f"Warning: Could not fetch model from MLflow: {e}")
                  print("Using default 'latest' version")
                  with open("model_version.txt", "w") as f:
                      f.write("latest")
          except Exception as e:
              print(f"Error: {e}")
              with open("model_version.txt", "w") as f:
                  f.write("latest")
          PYTHON
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: Check Docker credentials
        id: check-docker
        run: |
          if [ -n "${{ secrets.DOCKER_USERNAME }}" ] && [ -n "${{ secrets.DOCKER_PASSWORD }}" ]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
          else
            echo "has_credentials=false" >> $GITHUB_OUTPUT
            echo "::warning::Docker Hub credentials not set. Building image only (not pushing)."
          fi
      
      - name: Login to Docker Hub
        if: steps.check-docker.outputs.has_credentials == 'true'
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      
      - name: Generate version tag
        id: version
        run: |
          VERSION=$(cat model_version.txt)
          SHORT_SHA=$(git rev-parse --short HEAD)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          
          # Create semantic version tag
          TAG="v${VERSION}-${SHORT_SHA}"
          
          echo "version_tag=$TAG" >> $GITHUB_OUTPUT
          echo "timestamp=$TIMESTAMP" >> $GITHUB_OUTPUT
          
          echo "Docker image will be tagged as: $TAG"
      
      - name: Set image tags
        id: image-tags
        run: |
          if [ "${{ steps.check-docker.outputs.has_credentials }}" == "true" ]; then
            echo "tag1=${{ secrets.DOCKER_USERNAME }}/crypto-predictor:${{ steps.version.outputs.version_tag }}" >> $GITHUB_OUTPUT
            echo "tag2=${{ secrets.DOCKER_USERNAME }}/crypto-predictor:latest" >> $GITHUB_OUTPUT
            echo "cache_from=type=registry,ref=${{ secrets.DOCKER_USERNAME }}/crypto-predictor:buildcache" >> $GITHUB_OUTPUT
            echo "cache_to=type=registry,ref=${{ secrets.DOCKER_USERNAME }}/crypto-predictor:buildcache,mode=max" >> $GITHUB_OUTPUT
          else
            echo "tag1=crypto-predictor:${{ steps.version.outputs.version_tag }}" >> $GITHUB_OUTPUT
            echo "tag2=crypto-predictor:latest" >> $GITHUB_OUTPUT
            echo "cache_from=" >> $GITHUB_OUTPUT
            echo "cache_to=" >> $GITHUB_OUTPUT
          fi
      
      - name: Build Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./Dockerfile
          push: false
          load: true
          tags: |
            ${{ steps.image-tags.outputs.tag1 }}
            ${{ steps.image-tags.outputs.tag2 }}
          cache-from: ${{ steps.image-tags.outputs.cache_from }}
          cache-to: ${{ steps.image-tags.outputs.cache_to }}
      
      - name: Test Docker image
        continue-on-error: true
        run: |
          echo "Testing Docker image..."
          
          # Use the tag from previous step
          IMAGE_TAG="${{ steps.image-tags.outputs.tag1 }}"
          
          echo "Testing image: $IMAGE_TAG"
          
          # Run container in background
          docker run -d --name test-api \
            -p 8000:8000 \
            -e MODEL_NAME=crypto-volatility-predictor \
            -e MODEL_STAGE=Production \
            $IMAGE_TAG || {
            echo "::warning::Could not start container. This may be expected if model is not available."
            exit 0
          }
          
          # Wait for container to start
          sleep 15
          
          # Test health endpoint
          echo "Testing health endpoint..."
          HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/health || echo "000")
          
          if [ "$HEALTH_STATUS" -eq 200 ]; then
            echo "âœ“ Health check passed"
          else
            echo "::warning::Health check returned status: $HEALTH_STATUS"
            docker logs test-api || true
            # Don't fail the build if health check fails (model might not be available)
          fi
          
          # Stop container
          docker stop test-api || true
          docker rm test-api || true
          
          echo "âœ“ Docker image test completed"
      
      - name: Push Docker image to registry
        if: steps.check-docker.outputs.has_credentials == 'true'
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ steps.image-tags.outputs.tag1 }}
            ${{ steps.image-tags.outputs.tag2 }}
          cache-from: ${{ steps.image-tags.outputs.cache_from }}
          cache-to: ${{ steps.image-tags.outputs.cache_to }}
      
      - name: Create deployment manifest
        run: |
          # Determine image name
          if [ "${{ steps.check-docker.outputs.has_credentials }}" == "true" ]; then
            IMAGE_NAME="${{ secrets.DOCKER_USERNAME }}/crypto-predictor:${{ steps.version.outputs.version_tag }}"
          else
            IMAGE_NAME="crypto-predictor:${{ steps.version.outputs.version_tag }}"
          fi
          
          cat << EOF > deployment-manifest.yaml
          ---
          apiVersion: v1
          kind: DeploymentManifest
          metadata:
            name: crypto-predictor-deployment
            version: ${{ steps.version.outputs.version_tag }}
            timestamp: ${{ steps.version.outputs.timestamp }}
            commit: ${{ github.sha }}
          
          spec:
            image: $IMAGE_NAME
            replicas: 2
            resources:
              limits:
                cpu: "2"
                memory: "4Gi"
              requests:
                cpu: "1"
                memory: "2Gi"
            environment:
              - name: MODEL_NAME
                value: crypto-volatility-predictor
              - name: MODEL_STAGE
                value: Production
            healthCheck:
              path: /health
              port: 8000
              initialDelaySeconds: 30
              periodSeconds: 10
          EOF
          
          echo "Deployment manifest created"
          cat deployment-manifest.yaml
      
      - name: Upload deployment artifacts
        uses: actions/upload-artifact@v4
        with:
          name: deployment-artifacts
          path: |
            deployment-manifest.yaml
            model_version.txt
      
      - name: Create GitHub Release
        if: github.event_name == 'push' && steps.check-docker.outputs.has_credentials == 'true'
        continue-on-error: true
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.version_tag }}
          name: Release ${{ steps.version.outputs.version_tag }}
          body: |
            ## ðŸš€ Production Deployment
            
            **Model Version**: ${{ steps.version.outputs.version_tag }}
            **Docker Image**: `${{ secrets.DOCKER_USERNAME }}/crypto-predictor:${{ steps.version.outputs.version_tag }}`
            **Commit**: ${{ github.sha }}
            **Timestamp**: ${{ steps.version.outputs.timestamp }}
            
            ### Deployment Instructions
            
            ```bash
            # Pull the image
            docker pull ${{ secrets.DOCKER_USERNAME }}/crypto-predictor:${{ steps.version.outputs.version_tag }}
            
            # Run container
            docker run -d -p 8000:8000 \
              -e MLFLOW_TRACKING_URI=<your-uri> \
              -e MODEL_NAME=crypto-volatility-predictor \
              -e MODEL_STAGE=Production \
              ${{ secrets.DOCKER_USERNAME }}/crypto-predictor:${{ steps.version.outputs.version_tag }}
            
            # Verify health
            curl http://localhost:8000/health
            ```
            
            ### Testing
            
            ```bash
            # Test prediction
            curl -X POST http://localhost:8000/predict \
              -H "Content-Type: application/json" \
              -d '{"features": [...]}'
            ```
          draft: false
          prerelease: false
      
      - name: Deployment summary
        run: |
          if [ -n "${{ secrets.DOCKER_USERNAME }}" ]; then
            IMAGE_NAME="${{ secrets.DOCKER_USERNAME }}/crypto-predictor:${{ steps.version.outputs.version_tag }}"
          else
            IMAGE_NAME="crypto-predictor:${{ steps.version.outputs.version_tag }}"
          fi
          
          echo "::notice::âœ… Deployment completed successfully!"
          echo "::notice::Docker image: $IMAGE_NAME"
          echo "::notice::Image also tagged as 'latest'"
          
          cat << EOF
          
          ================================================
          ðŸŽ‰ PRODUCTION DEPLOYMENT SUCCESSFUL
          ================================================
          
          Image: $IMAGE_NAME
          Commit: ${{ github.sha }}
          Timestamp: ${{ steps.version.outputs.timestamp }}
          
          To deploy:
          docker pull $IMAGE_NAME
          docker run -d -p 8000:8000 $IMAGE_NAME
          
          ================================================
          EOF

  notify:
    runs-on: ubuntu-latest
    name: Deployment Notification
    needs: [build-and-deploy]
    if: always()
    
    steps:
      - name: Send notification
        run: |
          if [[ "${{ needs.build-and-deploy.result }}" == "success" ]]; then
            echo "::notice::âœ… Production deployment successful!"
            echo "::notice::Docker image built and ready for deployment"
          else
            echo "::warning::âš ï¸ Production deployment had issues"
            echo "::warning::Check the build-and-deploy job logs for details"
            # Don't fail the notification job - it's just for reporting
          fi